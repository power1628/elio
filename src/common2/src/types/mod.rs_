use std::sync::Arc;

use arrow::array::{self as aa};
use arrow::datatypes::{DataType as ADataType, Field as AField, FieldRef as AFieldRef};

#[derive(Clone)]
pub enum LogicalType {
    Integer,
    String,
    VirtualNode,
    Node,
    VirtualRel,
    Rel,
    List(Box<LogicalType>),
    Struct(Vec<(Arc<str>, LogicalType)>),
    // MapBinary
    Mapb,
    // Any data type, represented in json
    Any,
}

pub mod fields {
    // node
    pub static NODE_ID: &str = "node_id";
    pub static LABELS: &str = "labels";
    pub static PROPERTIES: &str = "properties";
    // rel
    pub static REL_ID: &str = "rel_id";
    pub static START_NODE: &str = "start";
    pub static END_NODE: &str = "end";
    pub static REL_TYPE: &str = "type";
}

pub mod arrow_mapping {
    use std::sync::LazyLock;

    use arrow::datatypes::{DataType as ADataType, Field as AField, FieldRef};

    use super::fields;

    pub static LABLES_TYPE: LazyLock<ADataType> =
        LazyLock::new(|| ADataType::List(AField::new("items", ADataType::Utf8, false).into()));

    pub static NODE_ARROW_TYPE: LazyLock<ADataType> = LazyLock::new(|| {
        let fields = vec![
            AField::new(fields::NODE_ID, ADataType::UInt64, false),
            AField::new(fields::LABELS, LABLES_TYPE.clone(), false),
            AField::new(fields::PROPERTIES, ADataType::Binary, false),
        ];
        ADataType::Struct(fields.into())
    });

    pub static VIRTUAL_REL_ARROW_TYPE: LazyLock<ADataType> = LazyLock::new(|| {
        ADataType::Struct(
            vec![
                AField::new(fields::REL_ID, ADataType::UInt64, false),
                AField::new(fields::START_NODE, ADataType::UInt64, false),
                AField::new(fields::END_NODE, ADataType::UInt64, false),
                AField::new(fields::REL_TYPE, ADataType::Utf8, false),
            ]
            .into(),
        )
    });
    pub static REL_ARROW_TYPE: LazyLock<ADataType> = LazyLock::new(|| {
        ADataType::Struct(
            vec![
                AField::new(fields::REL_ID, ADataType::UInt64, false),
                AField::new(fields::START_NODE, ADataType::UInt64, false),
                AField::new(fields::END_NODE, ADataType::UInt64, false),
                AField::new(fields::REL_TYPE, ADataType::Utf8, false),
                AField::new(fields::PROPERTIES, ADataType::Binary, false),
            ]
            .into(),
        )
    });
}

impl LogicalType {
    pub fn physical_type(&self) -> ADataType {
        match self {
            LogicalType::Integer => ADataType::Int64,
            LogicalType::String => ADataType::Utf8,
            LogicalType::VirtualNode => ADataType::UInt64,
            LogicalType::Node => arrow_mapping::NODE_ARROW_TYPE.clone(),
            LogicalType::VirtualRel => arrow_mapping::VIRTUAL_REL_ARROW_TYPE.clone(),
            LogicalType::Rel => arrow_mapping::REL_ARROW_TYPE.clone(),
            LogicalType::List(item_type) => {
                let dtype = item_type.physical_type();
                ADataType::List(AField::new("list_item", dtype, false).into())
            }
            LogicalType::Struct(fields) => ADataType::Struct(
                fields
                    .iter()
                    .map(|(fname, ftype)| AFieldRef::from(AField::new(fname.as_ref(), ftype.physical_type(), false)))
                    .collect::<Vec<_>>()
                    .into(),
            ),
            LogicalType::Mapb => ADataType::Binary,
            LogicalType::Any => ADataType::Binary,
        }
    }

    pub fn physical_builder(&self, capacity: usize) -> Box<dyn aa::ArrayBuilder> {
        let atype = self.physical_type();
        aa::make_builder(&atype, capacity)
    }

    pub fn builder(&self, capacity: usize) -> ArrayBuilder {
        ArrayBuilder {
            logical: self.clone(),
            arrow_builder: self.physical_builder(capacity),
        }
    }
}

////////// Array

pub struct IntegerArrayBulder {
    pub inner: aa::builder::Int64Builder,
}

pub struct StringArrayBuilder {
    pub inner: aa::builder::StringBuilder,
}

pub struct NodeArrayBuilder {
    pub inner: aa::builder::StructBuilder,
}

pub struct Array {
    pub physical: aa::ArrayRef,
    // 存在 schema 中
    // pub logical: LogicalType,
}

/// execution time data type ->  ArrowType? {Type associated value}        -> ArrayArrayType
// 根据给定的 logical type 来 downcast 到对应的arrow的 type
// pub fn downcast(&self) {
//     let atype = self.logical.physical_type();
//     let array = self
//         .physical
//         .as_any()
//         .downcast_ref::<arrow::array::StructArray>()
//         .unwrap();
//     let field_i = array.column_by_name(column_name)
// }

// iterate over array, return scalar type iter

pub struct ArrayBuilder {
    pub logical: LogicalType,
    pub arrow_builder: Box<dyn aa::ArrayBuilder>,
}

pub struct DataChunk {
    pub columns: Vec<Array>,
}

fn upper_function(input: &DataChunk) -> Result<Array, String> {
    let col = &input.columns[0];
    let len = col.physical.len();
    // downcast col as string
    let array = col.physical.as_any().downcast_ref::<aa::array::StringArray>().unwrap();
    let otype = LogicalType::String;
    let mut builder = otype.physical_builder(len);
    let builder = builder
        .as_any_mut()
        .downcast_mut::<aa::builder::StringBuilder>()
        .unwrap();
    array
        .iter()
        .map(|x| builder.append_option(x.map(|x| x.to_uppercase().to_owned())));
    let output = builder.finish();
    Ok(Array {
        physical: Arc::new(output),
    })
}

/// This is used for wrting data.
/// (irToken, Expr)
/// output-> PropertyMa
/// we should rename to create_prop_map
fn create_map(input: &DataChunk) -> Result<Array, String> {
    let otype = LogicalType::Mapb;

    let mut builder = otype
        .physical_builder(1024)
        .into_box_any()
        .downcast::<aa::builder::BinaryBuilder>()
        .unwrap();
    // serialize to binary convert to binary
    //
    todo!()
}

// field access
// StructFieldAccess
// MapbFiledAccess
// 1. for struct types
// 2. for mapb types

// function signature,
// input, struct => output struct field
// input, mapb => output mapb field(Any)
// in storage we use mapb.
// but in query execution, we should support general datum types.
// maybe use json?
fn field_access(input: &DataChunk) -> Result<Array, String> {
    let col = &input.columns[0];
    // if col have data type of mapb
    // use mapb access
    // if col have data type of struct
    // use struct access
}

// transform type
// when eval expression,
// 1. the input needs to transform arrow type to user function type.A
// 2. should be noticed the output builder type. for owned scalar type at build time?
// | LogicalType      |      ArrowType      |     User Function Type      |      Owned Scalar         |.   Scalar Ref |. Builder |
// | Integer          |          i64.       |           i64               |           i64             |       i64.    | I64Builder |
// | String           |          utf8.      |           &str              |           String          |       &str.   | Utf8Builder |
// | VirtualNode      |          u64        |           NodeId            |          NodeId           |.       NodeId.| VirtualNodeBuilder |
// | Node             |       Struct        |        Node                 |.         Node             |.       NodeRef| NodeBuilder |
// | Rel              |.      Struct.       |       Rel                   |
//
//
//

// impl ExprExecutor {
//     pub fn execute_simple<I: Scalar, O: Scalar, F>(input: &Array, func: F) -> Result<Array, String>
//     where
//         F: Fn(I::RefType<'_>) -> O,
//         for<'a> &'a I::ArrayType: From<&'a Array>,
//     {
//         // down cast ArrayImpl to I::ArrayType
//         let input: &I::ArrayType = input.into();
//         let mut builder = <O::ArrayType as Array>::Builder::with_capacity(input.len());
//         for item in input.iter() {
//             match item {
//                 Some(arg) => builder.append(Some(func(arg).as_scalar_ref())),
//                 None => builder.append(None),
//             }
//         }
//         Ok(builder.finish().into())
//     }
// }
